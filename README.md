# Hermes

APC (Agent Client Protocol) client

## Overview

Hermes implements the Agent Client Protocol designed for integration with Neovim. It enables Neovim to communicate with AI coding agents following the standardized APC specification.

The goal of Hermes is to be a bridge between AI assistant coding tools and Neovim while making no assumptions about how the user want's to use APC communication in their Neovim setup.

Hermes currently has no UI (and may never), it exposes an api for making requests, hooks into requests that require responses, and autocommands for updates from an agent. You could use these to build any kind of workflow/UI you would like in Neovim. 

- Hermes publishes autocommands for each event recieved from an Agent that requires no response.
- Hermes provides an api for connecting to and sending requests to agents
- For requests that require responses (permissions, read requests, etc), You can provide hooks/callbacks into these requests, default implementations exist for some, but not all, of these hooks/callbacks. 

## Features

- [x] Full implementation of APC Client
- [x] Configurable capabilities (filesystem, terminal, etc)
- [x] Trigger Autocommands for messages/notifications
- [ ] Allow connectiing to Agents
  - [ ] Via stdio
  - [ ] Via http
  - [ ] Via linux socket
  - [ ] handle authentication
- [ ] Allow mode selection
- [ ] Allow model selection
- [ ] Allow agent to write to files
  - [ ] Automatically refresh open buffers that have been modified
- [ ] Allow agent to read files
- [ ] Allow agent to use terminal
  - [ ] Create autocommands for Agent progress in the terminal
- [ ] Allow user to give permission when needed
- [ ] Allow user to configure/turn off any/all aspects of APC (if, for example, you just want to send data to the agent but still interact with it via the CLI)
- [ ] Allow user to send prompts
  - [ ] Send files
  - [ ] Send text
  - [ ] Send images 
  - [ ] Send resource links
  - [ ] Send audio
  - [ ] Cancel

## Autocommands

Hermes generates autocommands for all messages sent between agent and client. Each autocommand has the data section of their argument populated by information from these interactions. Below is an example of hooking into an autocommand generated by hermes:

```lua
vim.api.nvim_create_autocmd("AgentTextMessage", {
    group = "Hermes",
    pattern = { "*" },
    callback = function(args)
        print("Recieved some text from our assistant: " .. args.data.text)
    end,
})
```

Below is a list of all autocommands, their purpose, and the data passed into the args of their respective callback functions.

<table>
  <thead>
    <tr>
      <th>Autocommand</th>
      <th>Data</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ClientTextMessage</code></td>
      <td><pre><code>{ sessionId: string, text: string, type: "text" }</code></pre></td>
      <td>Message text sent from the client</td>
    </tr>
    <tr>
      <td><code>ClientImageMessage</code></td>
      <td><pre><code>{ sessionId: string, data: string, mimeType: string, type: "image" }</code></pre></td>
      <td>An image sent from the Client</td>
    </tr>
    <tr>
      <td><code>ClientResourceMessage</code></td>
      <td><pre><code>{ sessionId: string, resource: string, type: "resource" }</code></pre></td>
      <td>A resource sent from the Client</td>
    </tr>
    <tr>
      <td><code>ClientResourceLinkMessage</code></td>
      <td><pre><code>{ sessionId: string, name: string, uri: string, type: "resourcelink" }</code></pre></td>
      <td>A resource link from the Client</td>
    </tr>
    <tr>
      <td><code>AgentTextMessage</code></td>
      <td><pre><code>{ sessionId: string, text: string, type: "text" }</code></pre></td>
      <td>a text message from the agent</td>
    </tr>
    <tr>
      <td><code>AgentImageMessage</code></td>
      <td><pre><code>{ sessionId: string, data: string, mimeType: string, type: "image" }</code></pre></td>
      <td>an image from the agent</td>
    </tr>
    <tr>
      <td><code>AgentResourceMessage</code></td>
      <td><pre><code>{ sessionId: string, resource: string, type: "resource" }</code></pre></td>
      <td>a resource from the agent</td>
    </tr>
    <tr>
      <td><code>AgentResourceLinkMessage</code></td>
      <td><pre><code>{ sessionId: string, name: string, uri: string, type: "resourcelink" }</code></pre></td>
      <td>a resource link from the agent</td>
    </tr>
    <tr>
      <td><code>AgentTextThought</code></td>
      <td><pre><code>{ sessionId: string, text: string, type: "text" }</code></pre></td>
      <td>text-based reasoning from the agent</td>
    </tr>
    <tr>
      <td><code>AgentImageThought</code></td>
      <td><pre><code>{ sessionId: string, data: string, mimeType: string, type: "image" }</code></pre></td>
      <td>image-based reasoning from the agent</td>
    </tr>
    <tr>
      <td><code>AgentResourceThought</code></td>
      <td><pre><code>{ sessionId: string, resource: string, type: "resource" }</code></pre></td>
      <td>resource-based reasoning from the agent</td>
    </tr>
    <tr>
      <td><code>AgentResourceLinkThought</code></td>
      <td><pre><code>{ sessionId: string, name: string, uri: string, type: "resourcelink" }</code></pre></td>
      <td>resource link reasoning from the agent</td>
    </tr>
    <tr>
      <td><code>AgentToolCall</code></td>
      <td><pre><code>{ sessionId: string, id: string, title: string, kind: string, status: string, content: array, locations: array }</code></pre></td>
      <td>Fired when the agent makes a tool call</td>
    </tr>
    <tr>
      <td><code>AgentToolCallUpdate</code></td>
      <td><pre><code>{ id: string, fields: array, meta: string }</code></pre></td>
      <td>Fired when a tool call is updated (e.g., progress, output)</td>
    </tr>
    <tr>
      <td><code>AgentAvailableCommands</code></td>
      <td><pre><code>{ availableCommands: array, meta: string }</code></pre></td>
      <td>Fired when available commands are updated</td>
    </tr>
    <tr>
      <td><code>AgentPlan</code></td>
      <td><pre><code>{ entries: array, meta: string }</code></pre></td>
      <td>Fired when the agent generates a plan</td>
    </tr>
    <tr>
      <td><code>AgentCurrentMode</code></td>
      <td><pre><code>{ id: string, meta: string }</code></pre></td>
      <td>Fired when the current mode changes</td>
    </tr>
    <tr>
      <td><code>AgentConfigOption</code></td>
      <td><pre><code>{ configOptions: array, meta: string }</code></pre></td>
      <td>Fired when configuration options are updated</td>
    </tr>
  </tbody>
</table>
